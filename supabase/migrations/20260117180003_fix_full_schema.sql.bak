-- Migration: Fix Atomic Functions and Missing Schema (Comprehensive)
-- Date: 2026-01-17
-- Replcaes failed 170000 and 180001 attempts

-- 1. Ensure columns exist (Idempotent)
ALTER TABLE restaurant_orders ADD COLUMN IF NOT EXISTS coupon_id UUID REFERENCES coupons(id) ON DELETE SET NULL;
ALTER TABLE restaurant_orders ADD COLUMN IF NOT EXISTS coupon_code VARCHAR(50);
ALTER TABLE restaurant_orders ADD COLUMN IF NOT EXISTS coupon_discount DECIMAL(10,2) DEFAULT 0;
ALTER TABLE restaurant_orders ADD COLUMN IF NOT EXISTS gift_card_amount DECIMAL(10,2) DEFAULT 0;
ALTER TABLE restaurant_orders ADD COLUMN IF NOT EXISTS loyalty_points_used INTEGER DEFAULT 0;
ALTER TABLE restaurant_orders ADD COLUMN IF NOT EXISTS loyalty_discount DECIMAL(10,2) DEFAULT 0;

-- 2. Ensure table exists
CREATE TABLE IF NOT EXISTS order_gift_card_usage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    order_id UUID NOT NULL REFERENCES restaurant_orders(id) ON DELETE CASCADE,
    gift_card_id UUID NOT NULL REFERENCES gift_cards(id) ON DELETE RESTRICT,
    amount_used DECIMAL(10,2) NOT NULL,
    balance_before DECIMAL(10,2) NOT NULL,
    balance_after DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. Ensure indexes exist
CREATE INDEX IF NOT EXISTS idx_order_gift_card_usage_order ON order_gift_card_usage(order_id);
CREATE INDEX IF NOT EXISTS idx_order_gift_card_usage_gift_card ON order_gift_card_usage(gift_card_id);

-- 4. Create/Replace Functions (Each function logic is isolated)

-- Atomic Gift Card Redemption
CREATE OR REPLACE FUNCTION redeem_giftcard_atomic(p_code TEXT, p_amount DECIMAL, p_order_id UUID)
RETURNS TABLE(success BOOLEAN, amount_redeemed DECIMAL, new_balance DECIMAL, gift_card_id UUID, error_message TEXT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
    v_card RECORD;
    v_redeem_amount DECIMAL;
BEGIN
    SELECT * INTO v_card FROM gift_cards WHERE code = UPPER(p_code) AND status = 'active' AND (expires_at IS NULL OR expires_at > NOW()) FOR UPDATE;
    IF NOT FOUND THEN
        RETURN QUERY SELECT false, 0::DECIMAL, 0::DECIMAL, NULL::UUID, 'Gift card not found, inactive, or expired'::TEXT;
        RETURN;
    END IF;
    IF v_card.current_balance <= 0 THEN
        RETURN QUERY SELECT false, 0::DECIMAL, v_card.current_balance, v_card.id, 'Gift card has no balance'::TEXT;
        RETURN;
    END IF;
    v_redeem_amount := LEAST(p_amount, v_card.current_balance);
    UPDATE gift_cards SET current_balance = current_balance - v_redeem_amount, status = CASE WHEN current_balance - v_redeem_amount <= 0 THEN 'redeemed' ELSE 'active' END, redeemed_at = CASE WHEN current_balance - v_redeem_amount <= 0 THEN NOW() ELSE redeemed_at END, updated_at = NOW() WHERE id = v_card.id;
    INSERT INTO gift_card_transactions(gift_card_id, transaction_type, amount, balance_after, order_id, notes) VALUES (v_card.id, 'redemption', -v_redeem_amount, v_card.current_balance - v_redeem_amount, p_order_id, 'Order redemption');
    IF p_order_id IS NOT NULL THEN
        INSERT INTO order_gift_card_usage(order_id, gift_card_id, amount_used, balance_before, balance_after) VALUES (p_order_id, v_card.id, v_redeem_amount, v_card.current_balance, v_card.current_balance - v_redeem_amount);
    END IF;
    RETURN QUERY SELECT true, v_redeem_amount, v_card.current_balance - v_redeem_amount, v_card.id, NULL::TEXT;
END;
$$;

-- Atomic Loyalty Points Redemption
CREATE OR REPLACE FUNCTION redeem_loyalty_points_atomic(p_user_id UUID, p_points INTEGER, p_order_id UUID, p_dollar_value DECIMAL)
RETURNS TABLE(success BOOLEAN, points_redeemed INTEGER, new_balance INTEGER, member_id UUID, error_message TEXT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
    v_member RECORD;
BEGIN
    SELECT * INTO v_member FROM loyalty_members WHERE user_id = p_user_id FOR UPDATE;
    IF NOT FOUND THEN
        RETURN QUERY SELECT false, 0, 0, NULL::UUID, 'User does not have a loyalty account'::TEXT;
        RETURN;
    END IF;
    IF v_member.available_points < p_points THEN
        RETURN QUERY SELECT false, 0, v_member.available_points::INTEGER, v_member.id, 'Insufficient points balance'::TEXT;
        RETURN;
    END IF;
    UPDATE loyalty_members SET available_points = available_points - p_points, last_activity = NOW(), updated_at = NOW() WHERE id = v_member.id;
    INSERT INTO loyalty_transactions(member_id, transaction_type, points, balance_after, description, reference_type, reference_id) VALUES (v_member.id, 'redeem', -p_points, v_member.available_points - p_points, 'Redeemed ' || p_points || ' points for $' || p_dollar_value || ' discount', 'order', p_order_id);
    RETURN QUERY SELECT true, p_points, (v_member.available_points - p_points)::INTEGER, v_member.id, NULL::TEXT;
END;
$$;

-- Atomic Coupon Application
CREATE OR REPLACE FUNCTION apply_coupon_atomic(p_code TEXT, p_user_id UUID, p_order_total DECIMAL, p_order_id UUID, p_module_type TEXT DEFAULT 'all')
RETURNS TABLE(success BOOLEAN, discount_amount DECIMAL, coupon_id UUID, error_message TEXT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
    v_coupon RECORD;
    v_user_usage_count INTEGER;
    v_calculated_discount DECIMAL;
BEGIN
    SELECT * INTO v_coupon FROM coupons WHERE code = UPPER(p_code) AND is_active = true AND (valid_from IS NULL OR valid_from <= NOW()) AND (valid_until IS NULL OR valid_until > NOW()) FOR UPDATE;
    IF NOT FOUND THEN
        RETURN QUERY SELECT false, 0::DECIMAL, NULL::UUID, 'Coupon not found, inactive, or expired'::TEXT;
        RETURN;
    END IF;
    IF v_coupon.applies_to != 'all' AND v_coupon.applies_to != p_module_type THEN
        RETURN QUERY SELECT false, 0::DECIMAL, v_coupon.id, 'Coupon not valid for this order type'::TEXT;
        RETURN;
    END IF;
    IF v_coupon.min_order_amount IS NOT NULL AND p_order_total < v_coupon.min_order_amount THEN
        RETURN QUERY SELECT false, 0::DECIMAL, v_coupon.id, ('Order total below minimum of $' || v_coupon.min_order_amount::TEXT)::TEXT;
        RETURN;
    END IF;
    IF v_coupon.usage_limit IS NOT NULL AND v_coupon.usage_count >= v_coupon.usage_limit THEN
        RETURN QUERY SELECT false, 0::DECIMAL, v_coupon.id, 'Coupon usage limit reached'::TEXT;
        RETURN;
    END IF;
    IF p_user_id IS NOT NULL AND v_coupon.per_user_limit IS NOT NULL THEN
        SELECT COUNT(*) INTO v_user_usage_count FROM coupon_usage WHERE coupon_id = v_coupon.id AND user_id = p_user_id;
        IF v_user_usage_count >= v_coupon.per_user_limit THEN
            RETURN QUERY SELECT false, 0::DECIMAL, v_coupon.id, 'You have already used this coupon the maximum number of times'::TEXT;
            RETURN;
        END IF;
    END IF;
    IF v_coupon.discount_type = 'percentage' THEN
        v_calculated_discount := p_order_total * (v_coupon.discount_value / 100);
        IF v_coupon.max_discount_amount IS NOT NULL THEN
            v_calculated_discount := LEAST(v_calculated_discount, v_coupon.max_discount_amount);
        END IF;
    ELSIF v_coupon.discount_type = 'fixed_amount' THEN
        v_calculated_discount := LEAST(v_coupon.discount_value, p_order_total);
    ELSE
        v_calculated_discount := 0;
    END IF;
    v_calculated_discount := ROUND(v_calculated_discount, 2);
    UPDATE coupons SET usage_count = usage_count + 1, updated_at = NOW() WHERE id = v_coupon.id;
    INSERT INTO coupon_usage(coupon_id, user_id, order_id, discount_applied) VALUES (v_coupon.id, p_user_id, p_order_id, v_calculated_discount);
    RETURN QUERY SELECT true, v_calculated_discount, v_coupon.id, NULL::TEXT;
END;
$$;

-- Atomic Loyalty Points Earning
CREATE OR REPLACE FUNCTION earn_loyalty_points_atomic(p_user_id UUID, p_order_total DECIMAL, p_order_id UUID, p_points_per_dollar INTEGER DEFAULT 1)
RETURNS TABLE(success BOOLEAN, points_earned INTEGER, new_balance INTEGER, tier_multiplier DECIMAL, error_message TEXT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
    v_member RECORD;
    v_tier RECORD;
    v_base_points INTEGER;
    v_final_points INTEGER;
BEGIN
    SELECT * INTO v_member FROM loyalty_members WHERE user_id = p_user_id FOR UPDATE;
    IF NOT FOUND THEN
        INSERT INTO loyalty_members(user_id, tier_id, total_points, available_points, lifetime_points)
        SELECT p_user_id, id, 0, 0, 0 FROM loyalty_tiers WHERE min_points = 0 ORDER BY sort_order LIMIT 1
        RETURNING * INTO v_member;
    END IF;
    SELECT * INTO v_tier FROM loyalty_tiers WHERE id = v_member.tier_id;
    v_base_points := FLOOR(p_order_total * p_points_per_dollar);
    v_final_points := FLOOR(v_base_points * COALESCE(v_tier.points_multiplier, 1));
    UPDATE loyalty_members SET available_points = available_points + v_final_points, total_points = total_points + v_final_points, lifetime_points = lifetime_points + v_final_points, last_activity = NOW(), updated_at = NOW() WHERE id = v_member.id;
    INSERT INTO loyalty_transactions(member_id, transaction_type, points, balance_after, description, reference_type, reference_id) VALUES (v_member.id, 'earn', v_final_points, v_member.available_points + v_final_points, 'Earned ' || v_final_points || ' points from order', 'order', p_order_id);
    RETURN QUERY SELECT true, v_final_points, (v_member.available_points + v_final_points)::INTEGER, COALESCE(v_tier.points_multiplier, 1)::DECIMAL, NULL::TEXT;
END;
$$;

-- Inventory Deduction for Order
CREATE OR REPLACE FUNCTION deduct_inventory_for_order(p_order_id UUID)
RETURNS TABLE(success BOOLEAN, items_deducted INTEGER, error_message TEXT)
LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
    v_order_item RECORD;
    v_ingredient RECORD;
    v_deduction_count INTEGER := 0;
    v_total_needed DECIMAL;
BEGIN
    FOR v_order_item IN SELECT oi.menu_item_id, oi.quantity FROM restaurant_order_items oi WHERE oi.order_id = p_order_id
    LOOP
        FOR v_ingredient IN SELECT mii.inventory_item_id, mii.quantity_required, ii.name, ii.current_stock FROM menu_item_ingredients mii JOIN inventory_items ii ON ii.id = mii.inventory_item_id WHERE mii.menu_item_id = v_order_item.menu_item_id FOR UPDATE OF ii
        LOOP
            v_total_needed := v_ingredient.quantity_required * v_order_item.quantity;
            UPDATE inventory_items SET current_stock = current_stock - v_total_needed, updated_at = NOW() WHERE id = v_ingredient.inventory_item_id;
            INSERT INTO inventory_transactions(item_id, transaction_type, quantity, stock_before, stock_after, reference_type, reference_id, notes) VALUES (v_ingredient.inventory_item_id, 'sale', -v_total_needed, v_ingredient.current_stock, v_ingredient.current_stock - v_total_needed, 'order', p_order_id, 'Auto-deducted for order');
            v_deduction_count := v_deduction_count + 1;
        END LOOP;
    END LOOP;
    RETURN QUERY SELECT true, v_deduction_count, NULL::TEXT;
END;
$$;

-- Grant permissions
GRANT EXECUTE ON FUNCTION redeem_giftcard_atomic TO service_role;
GRANT EXECUTE ON FUNCTION redeem_loyalty_points_atomic TO service_role;
GRANT EXECUTE ON FUNCTION apply_coupon_atomic TO service_role;
GRANT EXECUTE ON FUNCTION earn_loyalty_points_atomic TO service_role;
GRANT EXECUTE ON FUNCTION deduct_inventory_for_order TO service_role;

-- RLS for order_gift_card_usage
ALTER TABLE order_gift_card_usage ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Staff can manage order_gift_card_usage" ON order_gift_card_usage;
CREATE POLICY "Staff can manage order_gift_card_usage" ON order_gift_card_usage FOR ALL USING (
    EXISTS (SELECT 1 FROM user_roles ur JOIN roles r ON ur.role_id = r.id WHERE ur.user_id = auth.uid() AND r.name IN ('admin', 'super_admin', 'staff'))
);

DROP POLICY IF EXISTS "Users can view own order_gift_card_usage" ON order_gift_card_usage;
CREATE POLICY "Users can view own order_gift_card_usage" ON order_gift_card_usage FOR SELECT USING (
    EXISTS (SELECT 1 FROM restaurant_orders o WHERE o.id = order_id AND o.customer_id = auth.uid())
);
